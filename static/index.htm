<html>

<head>
  <title>INFO 4310 - HW2</title>
  <!-- TODO-C: temp styles from old assignment, feel free to update -->
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
  <link href="./style.css" rel="stylesheet" type="text/css">

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>
  <style>
    .row {
      display: flex;
      flex-direction: row;
      justify-content: center
    }

    .column {
      display: flex;
      flex-direction: column;
    }

    /* below are all styling for the range slider */
    .range_container {
      display: flex;
      flex-direction: column;
      width: 80%;
      margin: 100px auto;
    }

    .sliders_control {
      position: relative;
      min-height: 30px;
    }

    .form_control {
      position: relative;
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #635a5a;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      pointer-events: all;
      width: 12px;
      height: 12px;
      background-color: #fff;
      border-radius: 50%;
      box-shadow: 0 0 0 1px #C6C6C6;
      cursor: pointer;
    }

    input[type=range]::-moz-range-thumb {
      -webkit-appearance: none;
      pointer-events: all;
      width: 12px;
      height: 12px;
      background-color: #fff;
      border-radius: 50%;
      box-shadow: 0 0 0 1px #C6C6C6;
      cursor: pointer;
    }

    input[type=range]::-webkit-slider-thumb:hover {
      background: #f7f7f7;
    }

    input[type=range]::-webkit-slider-thumb:active {
      box-shadow: inset 0 0 3px #387bbe, 0 0 9px #387bbe;
      -webkit-box-shadow: inset 0 0 3px #387bbe, 0 0 9px #387bbe;
    }

    input[type="number"] {
      color: #8a8383;
      width: 50px;
      height: 30px;
      font-size: 20px;
      border: none;
    }

    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      opacity: 1;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 2px;
      width: 100%;
      position: absolute;
      background-color: #C6C6C6;
      pointer-events: none;
    }

    #fromSlider {
      height: 0;
      z-index: 1;
    }
  </style>

</head>
<div class="row">
  <svg id="svgMap" width="600" height="600">
    <defs>
      <clipPath id="circleClip">
        <circle cx="250" cy="250" r="200" />
      </clipPath>
    </defs>
  </svg>

  <div class="column" style="margin: 10px;">
    <div id="controlfilter"></div>

    <!-- slider adapted from https://codepen.io/predragdavidovic/pen/mdpMoWo -->
    <div class="range_container">
      <div class="sliders_control">
        <input id="fromSlider" type="range" value="3.5" min="3.5" max="5" step="0.5" />
        <input id="toSlider" type="range" value="5" min="3.5" max="5" step="0.5" />
      </div>
      <div class="form_control">
        <div class="form_control_container">
          <div class="form_control_container__time">Min</div>
          <text class="form_control_container__time__input" id="fromInput">3.5</text>
        </div>
        <div class="form_control_container">
          <div class="form_control_container__time">Max</div>
          <text class="form_control_container__time__input" id="toInput">5</text>
        </div>
      </div>
    </div>
  </div>
</div>



<body>

  <script>

    function controlFromSlider(fromSlider, toSlider, fromInput) {
      console.log("from slider  moved");
      const [from, to] = [fromSlider.value, toSlider.value];
      fillSlider(fromSlider, toSlider, '#C6C6C6', '#25daa5', toSlider);
      if (from > to) {
        fromSlider.value = to;
        fromInput.text(to);
      } else {
        fromInput.value = from;
        fromInput.text(from);
      }
    }

    function controlToSlider(fromSlider, toSlider, toInput) {
      const [from, to] = [fromSlider.value, toSlider.value];
      fillSlider(fromSlider, toSlider, '#C6C6C6', '#25daa5', toSlider);
      setToggleAccessible(toSlider);
      if (from <= to) {
        toSlider.value = to;
        toInput.text(to);
      } else {
        toInput.value = from;
        toInput.text(from);
      }
    }

    function fillSlider(from, to, sliderColor, rangeColor, controlSlider) {
      const rangeDistance = to.max - to.min;
      const fromPosition = from.value - to.min;
      const toPosition = to.value - to.min;
      controlSlider.style.background = `linear-gradient(
      to right,
      ${sliderColor} 0%,
      ${sliderColor} ${(fromPosition) / (rangeDistance) * 100}%,
      ${rangeColor} ${((fromPosition) / (rangeDistance)) * 100}%,
      ${rangeColor} ${(toPosition) / (rangeDistance) * 100}%, 
      ${sliderColor} ${(toPosition) / (rangeDistance) * 100}%, 
      ${sliderColor} 100%)`;
    }

    function setToggleAccessible(currentTarget) {
      const toSlider = document.querySelector('#toSlider');
      if (Number(currentTarget.value) <= 0) {
        toSlider.style.zIndex = 2;
      } else {
        toSlider.style.zIndex = 0;
      }
    }

    const fromSlider = document.querySelector('#fromSlider');
    const toSlider = document.querySelector('#toSlider');
    const fromInput = d3.select('#fromInput');
    const toInput = d3.select('#toInput');
    fillSlider(fromSlider, toSlider, '#C6C6C6', '#25daa5', toSlider);
    setToggleAccessible(toSlider);

    fromSlider.oninput = () => controlFromSlider(fromSlider, toSlider, fromInput);
    toSlider.oninput = () => controlToSlider(fromSlider, toSlider, toInput);

  </script>
  <script id="map">
    const svgMap = d3.select("#svgMap");
    const width = svgMap.attr("width");
    const height = svgMap.attr("height");
    const deltas = [-100, -4, -1, 0];

    let url = (x, y, z) =>
      `https://api.mapbox.com/styles/v1/desaiwang/ckttxzrvq0s4i18l4he5vtltt/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoiZGVzYWl3YW5nIiwiYSI6ImNrc2puMHIyaTJmbWsydG41bmljMWExdjIifQ.A4w7M2K7sSIN-uLuXarl_w`


    const requestMapData = async () => {

      //eatery data
      const eateriesAll = await d3.csv("./yelp_boston.csv", d3.autoType);
      let eateries = eateriesAll; //this is used for filtering
      console.log(eateries)


      // //this is the amount of times buses stop at station per week
      // const frequencyExtentTransit = d3.extent(eateries, d => d['weekly_stop_counts']);
      // const frequencyScaleTransit = d3.scaleLog().domain(frequencyExtentTransit).range([2.5, 15]);



      const projection = d3.geoMercator()
        .scale(1 / (2 * Math.PI))
        .translate([0, 0]);


      const render = d3.geoPath(projection);

      const tile = d3.tile()
        .extent([[0, 0], [width, height]])
        .tileSize(512)
        .clampX(false);

      const levels = svgMap.append("g")
        .style('clip-path', "url(#circleClip)") //this clips the map to a circle
        .attr("pointer-events", "none")
        .selectAll("g")
        .data(deltas)
        .join("g")
        .style("opacity", null); //set to 0.3 to see low resolution files

      //Mouseover interaction
      let tooltipWidth = 250;
      let tooltipHeight = 45;

      let tooltip = svgMap.append("g")
        .attr("class", "tooltip")
        .attr("transform", `translate(${20},20)`)
        .attr("visibility", "hidden");

      let box = tooltip.append("rect")
        .attr("fill", "white")
        .attr("opacity", 0.8)
        .attr("x", 0)
        .attr("y", 0)
        .attr("height", tooltipHeight);

      let txt = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 5);
      let txt2 = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 25);

      let svgEateries = svgMap.append("g");
      //circles that represent eateries
      let circles = svgEateries.selectAll("circle.eateries").data(eateries)
        .join("circle")
        .attr("class", "eateries")
        .attr("r", 3)
        .attr("fill", "#ff3e03")
        .attr("opacity", 0.9)
        .attr("transform", (d) => {
          `translate(${projection([d.longitude, d.latitude])})`
        })
        .on("mouseover", (event) => {
          tooltip.style("visibility", "visible");


          let eatery = event.target.__data__

          //dynamically adjusts width, delete later
          tooltipWidth = eatery['name'].length * 10
          if (tooltipWidth < 100) { tooltipWidth = 120; }


          box.attr("width", tooltipWidth)

          txt.text(eatery['name']);
          txt2.text(`Rating: ${eatery['rating']}`)

          tooltip
            .raise();

        })
        .on("mouseout", (event) => {
          tooltip.style("visibility", "hidden");
        });


      var zoom = d3.zoom()
        .scaleExtent([1 << 18.5, 1 << 25])
        .on("zoom", ({ transform }) => zoomed(transform));

      svgMap
        .call(zoom)
        .call(zoom.transform, d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(- 1 << 19)
          .translate(...projection([-71.073, 42.348]))
          .scale(-1)
        )
        .on("mousewheel.zoom", null)
        .on("DOMMouseScroll.zoom", null); //disable scrolling while zooming


      function zoomed(transform) {

        levels.each(function (delta) {
          const tiles = tile.zoomDelta(delta)(transform);

          d3.select(this)
            .selectAll("image")
            .data(tiles, d => d)
            .join("image")
            .attr("xlink:href", d => url(...d3.tileWrap(d)))
            .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
            .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
            .attr("width", tiles.scale)
            .attr("height", tiles.scale);
        });


        projection
          .scale(transform.k / (2 * Math.PI))
          .translate([transform.x, transform.y]);

        circles
          .attr("transform", d => `translate(${projection([d.longitude, d.latitude])})`);
      };

      //from INFO3300 notes, makes brush histogram filter

      var filters = {};

      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {

          stillPassed = filterFunc(point) && stillPassed;

        });

        return stillPassed;

      }

      //calls update on filters
      function updateData() {

        // Filter the points using the filter dictionary first
        eateries = eateriesAll.filter(d => pointPassesFilters(d));

        console.log('filtered eateries', eateries);
        console.log(projection([]));
        // Draw the circles
        svgEateries.selectAll("circle.eateries").data(eateries)
          .join("circle")
          .attr("class", "eateries")
          .attr("r", 3)
          .attr("fill", "#ff3e03")
          .attr("opacity", 0.9)
          .attr("cx", 0)
          .attr("cy", 0)
          .attr("transform", (d) => {
            `translate(${projection([d.longitude, d.latitude])})`
          });
      }


      function makeSlider(container, label, attribute, sliderWidth, sliderHeight) {

        // Get a raw array of values for this property
        let values = eateries.map(d => d[attribute]);


        // Find min and max for some scales
        let minMax = d3.extent(values);
        console.log(minMax);
        let xScale = d3.scaleLinear().domain(minMax)
          .range([10, sliderWidth - 10]); // padding here for ease
        let xAxis = d3.axisBottom(xScale).tickFormat(d3.format(""));


        // Create some HTML elements
        let wrapper = container.append("div").attr("class", "controls");
        wrapper.append("div").text(label);
        let canvas = wrapper.append("svg").attr("width", sliderWidth)
          .attr("height", sliderHeight + 20)
          .attr("attribute", attribute);
        canvas.append("g").attr("transform", `translate(0,${sliderHeight})`)
          .call(xAxis);

        // Make an area chart
        let areaLayer = canvas.append("g");

        // Built-in d3 helper function to count up data
        let numBins = 10;

        // Program a histogram generator to count up data into "bins"
        let histoGen = d3.histogram().domain(minMax)
          .thresholds(numBins);
        let counts = histoGen(values);

        // add dummy object at start of graph
        counts.unshift({
          x0: 0,
          x1: counts[0].x0,
          length: counts[0].length
        });

        let yScale = d3.scaleLinear().domain(d3.extent(counts, d => d.length))
          .range([sliderHeight, 4]);

        // Area generator is like a lineGen, but we give y0 and y1 to fill it in
        let area = d3.area().x(d => xScale(d.x1))
          .y0(yScale(0))
          .y1(d => yScale(d.length))
          .curve(d3.curveNatural);

        // Adding the path works just like a line (the area generator just makes a filled region)
        areaLayer.append("path").datum(counts)
          .attr("class", "area")
          .attr("fill", "#ff3e03") //Color
          .attr("d", area);


        let filterFunc = d => true;
        filters[attribute] = filterFunc;

        var brush = d3.brushX().extent([[10, 0],                           // Upper left corner
        [sliderWidth - 10, sliderHeight]])  // Lower right corner
          .on("brush end", brushMoved);
        // NOTE: we still need to *call the brush* towards the end of our code to "paste" it into HTML

        function brushMoved(event) {

          console.log(event.type, event.selection);

          // Everything but clicking on brush area
          if (event.selection !== null) {

            // Run scales in reverse to get data values for the ends of the brush
            //  If a scale turns data -> pixels, then scale.invert turns pixels -> data
            let start = xScale.invert(event.selection[0]);
            let end = xScale.invert(event.selection[1]);

            // Overwrite old filter in our dictionary
            // This filter now only returns True if the point's value is between start and end
            let filterFunc = d => d[attribute] >= start && d[attribute] <= end;
            console.log(filterFunc);
            filters[attribute] = filterFunc;
            console.log(filters[attribute]);


            updateData();
            console.log(eateries);

          }
          // Clicking on brush area to empty it out
          else {
            // Selected nothing, let everything pass
            let filterFunc = d => true;
            filters[attribute] = filterFunc;

            updateData();
            console.log(eateries);

          }

        }
        canvas.append("g").attr("class", "brush").call(brush);
      }

      let controls = d3.select("#controlfilter");
      makeSlider(controls, "# of Reviews", "review_count", 250, 20);

    }

    requestMapData();





    function getDistanceFromLatLonInMiles(lat1, lon1, lat2, lon2) {
      var R = 3963; // Radius of the earth in miles
      var dLat = deg2rad(lat2 - lat1);
      var dLon = deg2rad(lon2 - lon1);
      var a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2)
        ;
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      var d = R * c;
      return d;
    }

    function deg2rad(deg) {
      return deg * (Math.PI / 180)
    }

  </script>
</body>