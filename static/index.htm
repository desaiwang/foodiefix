<html>

<head>
  <title>INFO 4310 - HW3</title>
  <!-- TODO-C: temp styles from old assignment, feel free to update -->
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
  <link href="./style.css" rel="stylesheet" type="text/css">

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>
  <style>
    .row {
      display: flex;
      flex-direction: row;
      justify-content: center
    }
  
    .restaurant-info-box {
    max-width: 30em;
    background-color: #f9f9f9;
    padding: 5px;
    border: 1px solid #ddd;
    border-radius: 5px;
    margin-top: -20px;
    }

    .restaurant-list {
      margin-top: 10px;
    
    }

    .restaurant-list a {
      text-decoration: none !important; color: inherit;
    }

    .restaurant-item {
      margin-bottom: 10px;
    }

    .restaurant-item p {
      margin: 0;
    }
    .restaurant-card {
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
      margin-bottom: 8px;
      background-color: #f9f9f9;
      font-size: medium;
    }

    .restaurant-name {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 2px;
    }

    .column {
      display: flex;
      flex-direction: column;
    }

    /* below are all styling for the range slider */
    /* NOTE I CHANGED THE MARGIN FROM ORIGINAL MAIN TO ALLOW FOR MORE LISTENTRIES TO APPEAR */
    .range_container {
      display: flex;
      flex-direction: column;
      width: 80%;
      margin: 40px auto;
    }

    .sliders_control {
      position: relative;
      min-height: 30px;
    }

    .form_control {
      position: relative;
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #635a5a;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      pointer-events: all;
      width: 12px;
      height: 12px;
      background-color: #fff;
      border-radius: 50%;
      box-shadow: 0 0 0 1px #C6C6C6;
      cursor: pointer;
    }

    input[type=range]::-moz-range-thumb {
      -webkit-appearance: none;
      pointer-events: all;
      width: 12px;
      height: 12px;
      background-color: #fff;
      border-radius: 50%;
      box-shadow: 0 0 0 1px #C6C6C6;
      cursor: pointer;
    }

    input[type=range]::-webkit-slider-thumb:hover {
      background: #f7f7f7;
    }

    input[type=range]::-webkit-slider-thumb:active {
      box-shadow: inset 0 0 3px #387bbe, 0 0 9px #387bbe;
      -webkit-box-shadow: inset 0 0 3px #387bbe, 0 0 9px #387bbe;
    }

    input[type="number"] {
      color: #8a8383;
      width: 50px;
      height: 30px;
      font-size: 20px;
      border: none;
    }

    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      opacity: 1;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 2px;
      width: 100%;
      position: absolute;
      background-color: #C6C6C6;
      pointer-events: none;
    }

    #fromSlider {
      height: 0;
      z-index: 1;
    }

    /* testing star generation */
    /* adapted from: https://jsfiddle.net/Auqj8/1/ */
    .star {
    font-size: x-large;
    width: 20px;
    display: inline-block;
    color: gray;
    }

    .star:last-child {
        margin-right: 0;
    }

    .star:before {
        content:'\2605';
    }

    .star.on {
        color: gold;
    }

    .star.half:after {
        content:'\2605';
        color: gold;
        position: absolute;
        margin-left: -20px;
        width: 10px;
        overflow: hidden;
    }
  </style>

</head>
<div class="row">
  <svg id="svgMap" width="600" height="600">
    <defs>
      <clipPath id="circleClip">
        <circle cx="250" cy="250" r="200" />
      </clipPath>
    </defs>
  </svg>

  <div class="column" style="margin: 10px;">
    <div id="controlfilter"></div>

    <!-- slider adapted from https://codepen.io/predragdavidovic/pen/mdpMoWo -->
    <div class="range_container">
      <div class="sliders_control">
        <input id="fromSlider" type="range" value="3.5" min="3.5" max="5" step="0.5" />
        <input id="toSlider" type="range" value="5" min="3.5" max="5" step="0.5" />
      </div>
      <div class="form_control">
        <div class="form_control_container">
          <div class="form_control_container__time">Min</div>
          <text class="form_control_container__time__input" id="fromInput">3.5</text>
        </div>
        <div class="form_control_container">
          <div class="form_control_container__time">Max</div>
          <text class="form_control_container__time__input" id="toInput">5</text>
        </div>
      </div>
    </div>
    <div style = "margin-bottom: 20px;"> <p><button id = "bestofbest" style = "margin-left:1em;"> Best of Best</button><button id = "revert" style = "margin-left:1em;"> Revert</button></p></div>
    <div id="restaurantInfoBox" class="restaurant-info-box">
      <h2>Restaurants Near You! </h2>
      <div id="restaurantList" class="restaurant-list" ></div>
    </div>
  </div>
</div>

<div id="stars-container"></div>

<body>

  <script>


    // function controlFromSlider(fromSlider, toSlider, fromInput) {
    //   console.log("from slider  moved");
    //   const [from, to] = [fromSlider.value, toSlider.value];
    //   fillSlider(fromSlider, toSlider, '#C6C6C6', '#25daa5', toSlider);
    //   if (from > to) {
    //     fromSlider.value = to;
    //     fromInput.text(to);
    //   } else {
    //     fromInput.value = from;
    //     fromInput.text(from);
    //   }
    // }

    // function controlToSlider(fromSlider, toSlider, toInput) {
    //   const [from, to] = [fromSlider.value, toSlider.value];
    //   fillSlider(fromSlider, toSlider, '#C6C6C6', '#25daa5', toSlider);
    //   setToggleAccessible(toSlider);
    //   if (from <= to) {
    //     toSlider.value = to;
    //     toInput.text(to);
    //   } else {
    //     toInput.value = from;
    //     toInput.text(from);
    //   }
    // }

    // function fillSlider(from, to, sliderColor, rangeColor, controlSlider, eateries) {
    //   const rangeDistance = to.max - to.min;
    //   const fromPosition = from.value - to.min;
    //   const toPosition = to.value - to.min;
    //   controlSlider.style.background = `linear-gradient(
    //   to right,
    //   ${sliderColor} 0%,
    //   ${sliderColor} ${(fromPosition) / (rangeDistance) * 100}%,
    //   ${rangeColor} ${((fromPosition) / (rangeDistance)) * 100}%,
    //   ${rangeColor} ${(toPosition) / (rangeDistance) * 100}%, 
    //   ${sliderColor} ${(toPosition) / (rangeDistance) * 100}%, 
    //   ${sliderColor} 100%)`;
    // }
  
    // function setToggleAccessible(currentTarget) {
    //   const toSlider = document.querySelector('#toSlider');
    //   if (Number(currentTarget.value) <= 0) {
    //     toSlider.style.zIndex = 2;
    //   } else {
    //     toSlider.style.zIndex = 0;
    //   }
    // }

    // const fromSlider = document.querySelector('#fromSlider');
    // const toSlider = document.querySelector('#toSlider');
    // const fromInput = d3.select('#fromInput');
    // const toInput = d3.select('#toInput');
    // fillSlider(fromSlider, toSlider, '#C6C6C6', '#25daa5', toSlider);
    // setToggleAccessible(toSlider);

    // fromSlider.oninput = () => controlFromSlider(fromSlider, toSlider, fromInput);
    // toSlider.oninput = () => controlToSlider(fromSlider, toSlider, toInput);
    //      // Filter by review values range
    // const fromValue = fromSlider.value;
    // const toValue = toSlider.value;
    // let reviewValueFilterFunc = d => d['rating'] >= fromValue && d['rating'] <= toValue;
    // let dum_eatery = entries;
    // eat_val = dum_eatery.filter(reviewValueFilterFunc);
    // // Update the filtered data
    // updateData();

    // // Update the restaurant list based on the filtered data
    // updateRestaurantInfoBox(eat_val);


  </script>
  <script id="map">
    const svgMap = d3.select("#svgMap");
    const width = svgMap.attr("width");
    const height = svgMap.attr("height");
    const deltas = [-100, -4, -1, 0];

    let url = (x, y, z) =>
      `https://api.mapbox.com/styles/v1/desaiwang/ckttxzrvq0s4i18l4he5vtltt/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoiZGVzYWl3YW5nIiwiYSI6ImNrc2puMHIyaTJmbWsydG41bmljMWExdjIifQ.A4w7M2K7sSIN-uLuXarl_w`


    const requestMapData = async () => {

      //eatery data
      const eateriesAll = await d3.csv("./yelp_boston.csv", d3.autoType);
      let eateries = eateriesAll; //this is used for filtering
      console.log(eateries)

      updateRestaurantInfoBox(eateries);
  

      const bestOfBestButton = document.getElementById('bestofbest');
      const filter_purp = eateries.slice()
      bestOfBestButton.addEventListener('click', () => {
        console.log("clicked best of best now sorting");
        const filtered_eat = filter_purp.sort((a, b) => {
          // Sort by rating descending
          if (a.rating !== b.rating) {
            return b.rating - a.rating;
          }
          // If ratings are the same, sort by review count descending
          return b.review_count - a.review_count;
        });

        // Call the update function with the sorted restaurants
        console.log(filtered_eat)
        console.log(eateries);
        updateRestaurantInfoBox(filtered_eat);

      });

      const revert = document.getElementById('revert');
      revert.addEventListener('click', () => {
        console.log("clicked revert orginal list");
        // Call the update function with the sorted restaurants
        console.log(eateries)
        updateRestaurantInfoBox(eateries);
      });
      
      


      const projection = d3.geoMercator()
        .scale(1 / (2 * Math.PI))
        .translate([0, 0]);


      const render = d3.geoPath(projection);

      const tile = d3.tile()
        .extent([[0, 0], [width, height]])
        .tileSize(512)
        .clampX(false);

      const levels = svgMap.append("g")
        // .style('clip-path', "url(#circleClip)") //this clips the map to a circle
        .attr("pointer-events", "none")
        .selectAll("g")
        .data(deltas)
        .join("g")
        .style("opacity", null); //set to 0.3 to see low resolution files

      //myLocation
      let myCoordinates = {
        latitude: 42.36541856,
        longitude: -71.05688332
      };

      let latdiff_1mile = 57.296 / 3963;

      let radiusBuffer = svgMap.append("circle")
        .attr("r", 15)
        .attr("fill", "#BD9DF0")
        .attr("opacity", 0.4)
        .attr("transform", `translate(${projection([myCoordinates.longitude, myCoordinates.latitude])})`);

      //Mouseover interaction
      let tooltipWidth = 250;
      let tooltipHeight = 45;

      let tooltip = svgMap.append("g")
        .attr("class", "tooltip")
        .attr("transform", `translate(${20},20)`)
        .attr("visibility", "hidden");

      let box = tooltip.append("rect")
        .attr("fill", "white")
        .attr("opacity", 0.8)
        .attr("x", 0)
        .attr("y", 0)
        .attr("height", tooltipHeight);

      let txt = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 5);
      let txt2 = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 25);

      let svgEateries = svgMap.append("g");

      //circles that represent eateries
      //set up colors 
      const selectedColor = "#7339D0";
      const greyedoutColor = "#A5A0AC";

      let circles = svgEateries.selectAll("circle.eateries").data(eateries)
        .join("circle")
        .attr("class", "eateries")
        .attr("r", 3)
        .attr("fill", selectedColor)
        .attr("opacity", 0.9)
        .attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`)
        .on("mouseover", (event) => {
          tooltip.style("visibility", "visible");


          let eatery = event.target.__data__

          //dynamically adjusts width, delete later
          tooltipWidth = eatery['name'].length * 10
          if (tooltipWidth < 100) { tooltipWidth = 120; }


          box.attr("width", tooltipWidth)

          txt.text(eatery['name']);
          txt2.text(`Rating: ${eatery['rating']} (${eatery['review_count']})`)

          tooltip
            .raise();

        })
        .on("mouseout", (event) => {
          tooltip.style("visibility", "hidden");
        });

      let myLocation = svgMap.selectAll("circle.me").data([myCoordinates])
        .join("circle")
        .attr("class", "me")
        .attr("r", 3)
        .attr("fill", "yellow")
        .attr("opacity", 1)
        .attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`)
        .call(d3.drag()
          // .on("start", (event, d) => console.log("drag start"))
          .on("drag", (event, d) => {
            // console.log("dragging");

            newCoords = projection.invert([event.x, event.y]);
            d.longitude = newCoords[0];
            d.latitude = newCoords[1];
            [myCoordinates.longitude, myCoordinates.latitude] = newCoords;
            updateMyLocation();

          })
          // .on("end", (event, d) => console.log("drag end"))
          .on("start.update drag.update end.update", console.log("update")));

      //updates myLocation, radiusBuffer, and eatery color

      function updateMyLocation() {
        console.log("distance: ", getDistanceFromLatLonInMiles(myCoordinates.latitude, myCoordinates.longitude, myCoordinates.latitude + latdiff_1mile * 3, myCoordinates.longitude))

        let screen_myLocation = projection([myCoordinates.longitude, myCoordinates.latitude]);
        let screen_radiusEnd = projection([myCoordinates.longitude, myCoordinates.latitude + latdiff_1mile]);
        let radius = screen_myLocation[1] - screen_radiusEnd[1];
        // console.log("mypt:", screen_myLocation)
        // console.log("1mile pt:", screen_radiusEnd)
        // console.log("dist radius", radius)

        myLocation.attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`);
        radiusBuffer
          .attr("r", radius)
          .attr("transform", (d) => `translate(${projection([myCoordinates.longitude, myCoordinates.latitude])})`);
        circles.attr("fill", (d) => {
          d.dist = getDistanceFromLatLonInMiles(myCoordinates.latitude, myCoordinates.longitude, d.latitude, d.longitude);
          if (d.dist < 1) { return selectedColor }
          else { return greyedoutColor }
        })

      }
      var zoom = d3.zoom()
        .scaleExtent([1 << 18.5, 1 << 25])
        .on("zoom", ({ transform }) => zoomed(transform));

      svgMap
        .call(zoom)
        .call(zoom.transform, d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(- 1 << 19)
          .translate(...projection([-71.073, 42.348]))
          .scale(-1)
        )
        .on("mousewheel.zoom", null)
        .on("DOMMouseScroll.zoom", null); //disable scrolling while zooming


      function zoomed(transform) {
        // console.log("regular projection", projection([42.36541856, -71.05688332]))

        levels.each(function (delta) {
          const tiles = tile.zoomDelta(delta)(transform);

          d3.select(this)
            .selectAll("image")
            .data(tiles, d => d)
            .join("image")
            .attr("xlink:href", d => url(...d3.tileWrap(d)))
            .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
            .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
            .attr("width", tiles.scale)
            .attr("height", tiles.scale);
        });


        projection
          .scale(transform.k / (2 * Math.PI))
          .translate([transform.x, transform.y]);

        circles
          .attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`);

        updateMyLocation();
      };

      //from INFO3300 notes, makes brush histogram filter

      var filters = {};

      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {

          stillPassed = filterFunc(point) && stillPassed;

        });

        return stillPassed;

      }

      //calls update on filters
      function updateData() {

        // Filter the points using the filter dictionary first
        eateries = eateriesAll.filter(d => pointPassesFilters(d));

        console.log('filtered eateries', eateries);
        // console.log(eateries[0]["longitude"], eateries[0]["latitude"]);
        // console.log(projection([eateries[0]["longitude"], eateries[0]["latitude"]]));
        // console.log(projection([-71.05686665, 42.35140831]));

        // Draw the circles
        circles = svgEateries.selectAll("circle.eateries").data(eateries)
          .join("circle")
          .attr("class", "eateries")
          .attr("r", 3)
          .attr("fill", selectedColor)
          .attr("opacity", 0.9)
          .attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`)
          .on("mouseover", (event) => {
            tooltip.style("visibility", "visible");


            let eatery = event.target.__data__

            //dynamically adjusts width, delete later
            tooltipWidth = eatery['name'].length * 10
            if (tooltipWidth < 100) { tooltipWidth = 120; }


            box.attr("width", tooltipWidth)

            txt.text(eatery['name']);
            txt2.text(`Rating: ${eatery['rating']}, ${eatery['review_count']}`)

            tooltip
              .raise();

          })
          .on("mouseout", (event) => {
            tooltip.style("visibility", "hidden");
          });


      }


      function makeSlider(container, label, attribute, sliderWidth, sliderHeight) {

        // Get a raw array of values for this property
        let values = eateries.map(d => d[attribute]);


        // Find min and max for some scales
        let minMax = d3.extent(values);
        // console.log(minMax);
        let xScale = d3.scaleLinear().domain(minMax)
          .range([10, sliderWidth - 10]); // padding here for ease
        let xAxis = d3.axisBottom(xScale).tickFormat(d3.format(""));


        // Create some HTML elements
        let wrapper = container.append("div").attr("class", "controls");
        wrapper.append("div").text(label);
        let canvas = wrapper.append("svg").attr("width", sliderWidth)
          .attr("height", sliderHeight + 20)
          .attr("attribute", attribute);
        canvas.append("g").attr("transform", `translate(0,${sliderHeight})`)
          .call(xAxis);

        // Make an area chart
        let areaLayer = canvas.append("g");

        // Built-in d3 helper function to count up data
        let numBins = 10;

        // Program a histogram generator to count up data into "bins"
        let histoGen = d3.histogram().domain(minMax)
          .thresholds(numBins);
        let counts = histoGen(values);

        // add dummy object at start of graph
        counts.unshift({
          x0: 0,
          x1: counts[0].x0,
          length: counts[0].length
        });

        let yScale = d3.scaleLinear().domain(d3.extent(counts, d => d.length))
          .range([sliderHeight, 4]);

        // Area generator is like a lineGen, but we give y0 and y1 to fill it in
        let area = d3.area().x(d => xScale(d.x1))
          .y0(yScale(0))
          .y1(d => yScale(d.length))
          .curve(d3.curveNatural);

        // Adding the path works just like a line (the area generator just makes a filled region)
        areaLayer.append("path").datum(counts)
          .attr("class", "area")
          .attr("fill", "#ff3e03") //Color
          .attr("d", area);


        let filterFunc = d => true;
        filters[attribute] = filterFunc;

        var brush = d3.brushX().extent([[10, 0],                           // Upper left corner
        [sliderWidth - 10, sliderHeight]])  // Lower right corner
          .on("brush end", brushMoved);
        // NOTE: we still need to *call the brush* towards the end of our code to "paste" it into HTML

        function brushMoved(event) {

          // console.log(event.type, event.selection);

          // Everything but clicking on brush area
          if (event.selection !== null) {

            // Run scales in reverse to get data values for the ends of the brush
            //  If a scale turns data -> pixels, then scale.invert turns pixels -> data
            let start = xScale.invert(event.selection[0]);
            let end = xScale.invert(event.selection[1]);

            // Overwrite old filter in our dictionary
            // This filter now only returns True if the point's value is between start and end
            let filterFunc = d => d[attribute] >= start && d[attribute] <= end;
            filters[attribute] = filterFunc;

            updateData();
            updateRestaurantInfoBox(eateries);


          }
          // Clicking on brush area to empty it out
          else {
            // Selected nothing, let everything pass
            let filterFunc = d => true;
            filters[attribute] = filterFunc;
            updateData();

          }

        }
        canvas.append("g").attr("class", "brush").call(brush);
      }

        let controls = d3.select("#controlfilter");
        makeSlider(controls, "# of Reviews", "review_count", 250, 20);


        function controlFromSlider(fromSlider, toSlider, fromInput) {
        console.log("from slider  moved");
        const [from, to] = [fromSlider.value, toSlider.value];
        fillSlider(fromSlider, toSlider, '#C6C6C6', '#25daa5', toSlider);
        if (from > to) {
          fromSlider.value = to;
          fromInput.text(to);
        } else {
          fromInput.value = from;
          fromInput.text(from);
        }
        filterRestaurants();
      }

      function controlToSlider(fromSlider, toSlider, toInput) {
        const [from, to] = [fromSlider.value, toSlider.value];
        fillSlider(fromSlider, toSlider, '#C6C6C6', '#25daa5', toSlider);
        setToggleAccessible(toSlider);
        if (from <= to) {
          toSlider.value = to;
          toInput.text(to);
        } else {
          toInput.value = from;
          toInput.text(from);
        }
        filterRestaurants();

      }

      function fillSlider(from, to, sliderColor, rangeColor, controlSlider) {
        const rangeDistance = to.max - to.min;
        const fromPosition = from.value - to.min;
        const toPosition = to.value - to.min;
        controlSlider.style.background = `linear-gradient(
        to right,
        ${sliderColor} 0%,
        ${sliderColor} ${(fromPosition) / (rangeDistance) * 100}%,
        ${rangeColor} ${((fromPosition) / (rangeDistance)) * 100}%,
        ${rangeColor} ${(toPosition) / (rangeDistance) * 100}%, 
        ${sliderColor} ${(toPosition) / (rangeDistance) * 100}%, 
        ${sliderColor} 100%)`;
      }
    
      function setToggleAccessible(currentTarget) {
        const toSlider = document.querySelector('#toSlider');
        if (Number(currentTarget.value) <= 0) {
          toSlider.style.zIndex = 2;
        } else {
          toSlider.style.zIndex = 0;
        }
      }

      const fromSlider = document.querySelector('#fromSlider');
      const toSlider = document.querySelector('#toSlider');
      const fromInput = d3.select('#fromInput');
      const toInput = d3.select('#toInput');
      fillSlider(fromSlider, toSlider, '#C6C6C6', '#25daa5', toSlider);
      setToggleAccessible(toSlider);

      // Attach event listeners to the sliders
      fromSlider.addEventListener('input', () => controlFromSlider(fromSlider, toSlider, fromInput));
      toSlider.addEventListener('input', () => controlToSlider(fromSlider, toSlider, toInput));
          
      
      
      
      
      // Filter by review values range
      function filterRestaurants() {
        console.log("triggered fliter slide")
      
        const fromValue = (fromSlider.value);
        const toValue = (toSlider.value);
        console.log(`from value: ${fromValue}`)
        console.log(`To value: ${toValue}`)
        let dum_eatery = eateries;
        const filteredRestaurants = dum_eatery.filter(d => d.rating >= fromValue && d.rating <= toValue);
        console.log(filteredRestaurants)
        // Update the restaurant list based on the filtered data
        updateData();
        updateRestaurantInfoBox(filteredRestaurants);
      }

    

    }

    requestMapData();





    function getDistanceFromLatLonInMiles(lat1, lon1, lat2, lon2) {
      var R = 3963; // Radius of the earth in miles
      var dLat = deg2rad(lat2 - lat1);
      var dLon = deg2rad(lon2 - lon1);
      var a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2)
        ;
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      var d = R * c;
      return d;
    }

    function deg2rad(deg) {
      return deg * (Math.PI / 180)
    }

    
    // Number of stars to create
    const numStars = 5;

    // Function to create a star element
    function createStar(isFilled, isHalf) {
        const star = document.createElement('span');
        star.classList.add('star');
        if (isFilled) {
            star.classList.add('on');
        }
        if (isHalf) {
            star.classList.add('half');
        }
        return star;
    }

    // Function to generate stars
    function generateStars(rating) {
        let div = document.createElement("div");

        // Clear previous stars
        div.innerHTML = '';

        let p = document.createElement("p");
        p.textContent = "Rating: ";
        p.style.display = "inline"; // Set display to inline
        div.appendChild(p);

        // Calculate full stars
        const fullStars = Math.floor(rating);

        // Calculate half star
        const hasHalfStar = rating % 1 !== 0;

        // Generate full stars
        for (let i = 0; i < fullStars; i++) {
            const star = createStar(true, false);
            div.appendChild(star);
        }

        // Generate half star
        if (hasHalfStar) {
            const halfStar = createStar(false, true);
            div.appendChild(halfStar);
        }

        // Generate empty stars
        const emptyStars = numStars - fullStars - (hasHalfStar ? 1 : 0);
        for (let i = 0; i < emptyStars; i++) {
            const star = createStar(false, false);
            div.appendChild(star);
        }

        return div;
    }

    function updateRestaurantInfoBox(restaurants) {
      console.log(restaurants)
        // const STAR_RATING = {
        //   1: '★☆☆☆☆',
        //   2: '★★☆☆☆',
        //   3: '★★★☆☆',
        //   3.5: '★★★½☆',
        //   4: '★★★★☆',
        //   4.5: '★★★★½',
        //   5: '★★★★★'
        // };

      const restaurantListDiv = d3.select('#restaurantList');
      restaurantListDiv.selectAll("*").remove();



      // Bind data to restaurant cards
      const restaurantCards = restaurantListDiv.selectAll('.restaurant-card')
        .data(restaurants.slice(0, 5)); // Limit to first 5 restaurants

      // Enter selection - create new elements for restaurants
      const newRestaurantCards = restaurantCards.enter()
        .append('div')
        .attr('class', 'restaurant-card');

      const anchorTags = newRestaurantCards.append('a')
        .attr('href', d => d.url) // Set href attribute to the restaurant's URL
        .attr('target', '_blank'); // Open link in a new tab

      anchorTags.style('color', 'inherit')
        .style('text-decoration', 'none');

      // Append anchor tags to new restaurant cards
      anchorTags.append('a')
        .attr('href', d => d.url) // Set href attribute to the restaurant's URL
        .attr('target', '_blank') // Open link in a new tab
        .each(function (d) {
          // For each anchor tag, append details of the restaurant
          
          d3.select(this)
            .append('p')
            .attr('class', 'restaurant-name')
            .text(d => d.name);

          let ratings_temp = d.rating;

          d3.select(this)
          .append('div')
          .node()
          .appendChild(generateStars(ratings_temp));
            // .append('p')
            // .text(d => `Rating: ${STAR_RATING[d.rating]}`);

          d3.select(this)
            .append('p')
            .text(d => `Review Count: ${d.review_count}`);

          const categories = JSON.parse(d.categories_json).map(category => category[0]).join(', ');
          d3.select(this)
            .append('p')
            .text(`Categories: ${categories}`);

          const locationInfo = JSON.parse(d.location_json);
          d3.select(this)
            .append('p')
            .text(`Address: ${locationInfo.display_address.join(', ')}`);

          d3.select(this)
            .append('p')
            .text(d => `Snippet: ${d.snippet_text}`);
        });

      // Update existing restaurant cards
      restaurantCards.select('a')
        .attr('href', d => d.url);

      // Remove excess restaurant cards
      restaurantCards.exit().remove();



  /** TODO: TO THINK ABOUT WHEN NEXT PICKUP
   *  a scroll bar to contain the resturants
   * the category icons buttons!
   * distance filter? 
   * animation to smoothen transitions
   * maybe switch the two buttons to a single toggle
   * add the rating number next to the stars and the number of reviews in '()' next to the review number
   *  create an distinction between "best of best" and "all results"
   * add comment icon for the speech
   * */
}

  </script>
  
</body>