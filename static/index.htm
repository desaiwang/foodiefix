<html>

<head>
  <title>INFO 4310 - HW3</title>
  <!-- TODO-C: temp styles from old assignment, feel free to update -->
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="./style.css" rel="stylesheet" type="text/css">

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-tile@1"></script>
  <style>
    .row {
      display: flex;
      flex-direction: row;
      justify-content: center
    }

    .restaurant-info-box {
      max-width: 30em;
      background-color: #f9f9f9;
      padding: 5px;
      border: 1px solid #ddd;
      border-radius: 5px;
      margin-top: -20px;
    }

    .restaurant-list {
      margin-top: 10px;

    }

    .restaurant-list a {
      text-decoration: none !important;
      color: inherit;
    }

    .restaurant-item {
      margin-bottom: 10px;
    }

    .restaurant-item p {
      margin: 0;
    }

    .restaurant-card {
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
      margin-bottom: 8px;
      background-color: #f9f9f9;
      font-size: medium;
    }

    .restaurant-name {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 2px;
    }

    .column {
      display: flex;
      flex-direction: column;
    }

    button {
      background-color: #ffffff;
      /* Green */
      border: 2px solid #8a8a8a;
      color: #8a8a8a;
      border-radius: 10px;
      padding: 5px 10px;
    }

    .clicked {
      background-color: #e3d2fd;
      /* Green */
      border: 2px solid #7339D0;
      color: #7339D0;
      border-radius: 10px;
      padding: 5px 10px;
    }

    .fa-star-o {
      color: #7339D0
    }

    .fa.checked {
      color: #7339D0
    }

    .fa-star-half-full {
      color: #7339D0
    }
  </style>

</head>
<div class="row">
  <svg id="svgMap" width="600" height="600">
    <defs>
      <clipPath id="circleClip">
        <circle cx="250" cy="250" r="200" />
      </clipPath>
    </defs>
  </svg>

  <div class="column" style="margin: 10px;">
    <svg id="histogram" width=500 height=120></svg>

    <div id="distance" style="margin-bottom: 20px;">
      <p><button id="mi0.25" style="margin-left:1em;"> 0.25 mi</button>
        <button id="mi0.5" style="margin-left:1em;"> 0.5 mi</button>
        <button id="mi1" style="margin-left:1em;"> 1 mi</button>
      </p>
    </div>

    <div id="restaurantInfoBox" class="restaurant-info-box">
      <h2>Restaurants Near You </h2>
      <div id="restaurantList" class="restaurant-list"></div>
    </div>
  </div>
</div>


<body>

  <script id="map">
    const svgMap = d3.select("#svgMap");
    const width = svgMap.attr("width");
    const height = svgMap.attr("height");
    const deltas = [-100, -4, -1, 0];

    let url = (x, y, z) =>
      `https://api.mapbox.com/styles/v1/desaiwang/ckttxzrvq0s4i18l4he5vtltt/tiles/${z}/${x}/${y}${devicePixelRatio > 1 ? "@2x" : ""}?access_token=pk.eyJ1IjoiZGVzYWl3YW5nIiwiYSI6ImNrc2puMHIyaTJmbWsydG41bmljMWExdjIifQ.A4w7M2K7sSIN-uLuXarl_w`


    const requestMapData = async () => {

      let latdiff_1mile = 57.296 / 3963;
      let curr_latdiff = 0;
      let filter_dist = Infinity;

      //eatery data
      let eateriesAll = await d3.csv("./yelp_boston.csv", d3.autoType);
      eateriesAll = eateriesAll.sort((a, b) => {

        // Sort by rating descending
        if (a.rating !== b.rating) {
          return b.rating - a.rating;
        }

        // If ratings are the same, sort by review count descending
        return b.review_count - a.review_count;
      });

      //set up histogram
      const marginHist = ({ top: 20, right: 20, bottom: 40, left: 20 })
      const widthHist = 200;
      const heightHist = 100;
      let bins = d3.bin().thresholds(4).value(d => d.rating)(eateriesAll);
      console.log("bins", bins);
      let barPadding = 1;
      let svgHist = d3.select("#histogram");

      xScale = d3
        .scaleLinear()
        .domain([bins[0].x0, bins[bins.length - 1].x1])
        .range([marginHist.left, widthHist - marginHist.right])

      x = d3.scaleBand()
        .domain([3.5, 4, 4.5, 5])
        .range([marginHist.left, widthHist - marginHist.right])
        .padding(0.3)

      yScale = d3
        .scaleSymlog()
        .domain([0, d3.max(bins, d => d.length)])
        .nice()
        .range([heightHist - marginHist.bottom, marginHist.top])

      let xAxis = (g) => {
        g
          .attr("transform", `translate(${0},${heightHist - marginHist.bottom})`)
          .call(
            d3.axisBottom(x)
              .ticks(5)
              .tickSizeOuter(0)
          )
      };

      svgHist
        .append("g")
        .attr("fill", "steelblue")
        .selectAll("rect")
        .data(bins)
        .join("rect")
        .attr("x", d => xScale(d.x0) + barPadding) // position of each bar on xAxis, width adjustment (bar padding)
        .attr("y", d => yScale(d.length))
        .attr("width", d => d3.max([0, xScale(d.x1) - xScale(d.x0) - barPadding]))
        .attr("height", d => yScale(0) - yScale(d.length))
        .on('mouseover', function (d, i) {
          console.log(i);
          d3.select(this).attr('style', 'fill: orange;');
          d3.select("#toptext").text(`Metropolitan Areas: ${i.length}`);
        })
        .on('mouseout', function (d, i) {
          d3.select(this).attr('style', 'outline: thin solid clear;');
          d3.select("#toptext").text(`Metropolitan Areas: ${0}`);
        });

      svgHist.append("g").call(xAxis);



      let eateries = eateriesAll; //this is used for filtering
      let eateriesInRadius = eateriesAll; //this is used for best of best list

      updateRestaurantInfoBox(eateriesInRadius);

      const mi1 = document.getElementById('mi1');
      const mi1_2 = document.getElementById('mi0.5');
      const mi1_4 = document.getElementById('mi0.25');

      let mi1_toggle = false;
      let mi1_2_toggle = false;
      let mi1_4_toggle = false;


      mi1.addEventListener('click', () => {
        mi1.classList.toggle('clicked');
        mi1_toggle = !mi1_toggle;

        mi1_2_toggle = false;
        mi1_4_toggle = false;

        update_dist();
      });
      mi1_2.addEventListener('click', () => {
        mi1_2.classList.toggle('clicked');
        mi1_toggle = false;
        mi1_2_toggle = !mi1_2_toggle;
        mi1_4_toggle = false;

        update_dist();
      });
      mi1_4.addEventListener('click', () => {
        mi1_4.classList.toggle('clicked');
        mi1_toggle = false;
        mi1_2_toggle = false;
        mi1_4_toggle = !mi1_4_toggle;

        update_dist();
      });

      function update_dist() {
        if (!mi1_toggle) {
          mi1.classList.remove('clicked');
        } else {
          curr_latdiff = latdiff_1mile
          filter_dist = 1;
        }

        if (!mi1_2_toggle) {
          mi1_2.classList.remove('clicked');
        } else {
          curr_latdiff = latdiff_1mile / 2
          filter_dist = 0.5;
        }

        if (!mi1_4_toggle) {
          mi1_4.classList.remove('clicked');
        } else {
          curr_latdiff = latdiff_1mile / 4
          filter_dist = 0.25;
        }

        if (!mi1_4_toggle && !mi1_2_toggle && !mi1_toggle) {
          curr_latdiff = 0
          filter_dist = Infinity;
        }
        updateMyLocation();
      }

      const projection = d3.geoMercator()
        .scale(1 / (2 * Math.PI))
        .translate([0, 0]);


      const render = d3.geoPath(projection);

      const tile = d3.tile()
        .extent([[0, 0], [width, height]])
        .tileSize(512)
        .clampX(false);

      const levels = svgMap.append("g")
        // .style('clip-path', "url(#circleClip)") //this clips the map to a circle
        .attr("pointer-events", "none")
        .selectAll("g")
        .data(deltas)
        .join("g")
        .style("opacity", null); //set to 0.3 to see low resolution files

      //myLocation
      let myCoordinates = {
        latitude: 42.36541856,
        longitude: -71.05688332
      };



      let radiusBuffer = svgMap.append("circle")
        .attr("r", 15)
        .attr("fill", "#BD9DF0")
        .attr("opacity", 0.4)
        .attr("transform", `translate(${projection([myCoordinates.longitude, myCoordinates.latitude])})`);

      //Mouseover interaction
      let tooltipWidth = 250;
      let tooltipHeight = 45;

      let tooltip = svgMap.append("g")
        .attr("class", "tooltip")
        .attr("transform", `translate(${20},20)`)
        .attr("visibility", "hidden");

      let box = tooltip.append("rect")
        .attr("fill", "white")
        .attr("opacity", 0.8)
        .attr("x", 0)
        .attr("y", 0)
        .attr("height", tooltipHeight);

      let txt = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 5);
      let txt2 = tooltip.append("text")
        .attr("fill", "black")
        // .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 10)
        .attr("y", 25);

      let svgEateries = svgMap.append("g");

      //circles that represent eateries
      //set up colors 
      const selectedColor = "#7339D0";
      const greyedoutColor = "#A5A0AC";

      let circles = svgEateries.selectAll("circle.eateries").data(eateries)
        .join("circle")
        .attr("class", "eateries")
        .attr("r", 3)
        .attr("fill", selectedColor)
        .attr("opacity", 0.9)
        .attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`)
        .on("mouseover", (event) => {
          tooltip.style("visibility", "visible");


          let eatery = event.target.__data__

          //dynamically adjusts width, delete later
          tooltipWidth = eatery['name'].length * 10
          if (tooltipWidth < 100) { tooltipWidth = 120; }


          box.attr("width", tooltipWidth)

          txt.text(eatery['name']);
          txt2.text(`Rating: ${eatery['rating']} (${eatery['review_count']})`)

          tooltip
            .raise();

        })
        .on("mouseout", (event) => {
          tooltip.style("visibility", "hidden");
        });

      let myLocation = svgMap.selectAll("circle.me").data([myCoordinates])
        .join("circle")
        .attr("class", "me")
        .attr("r", 3)
        .attr("fill", "yellow")
        .attr("opacity", 1)
        .attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`)
        .call(d3.drag()
          // .on("start", (event, d) => console.log("drag start"))
          .on("drag", (event, d) => {
            // console.log("dragging");

            newCoords = projection.invert([event.x, event.y]);
            d.longitude = newCoords[0];
            d.latitude = newCoords[1];
            [myCoordinates.longitude, myCoordinates.latitude] = newCoords;
            updateMyLocation();

          })
          // .on("end", (event, d) => console.log("drag end"))
          .on("start.update drag.update end.update", console.log("update")));

      //updates myLocation, radiusBuffer, and eatery color


      function updateMyLocation() {
        // console.log("distance: ", getDistanceFromLatLonInMiles(myCoordinates.latitude, myCoordinates.longitude, myCoordinates.latitude + latdiff_1mile * 3, myCoordinates.longitude))

        let screen_myLocation = projection([myCoordinates.longitude, myCoordinates.latitude]);
        let screen_radiusEnd = projection([myCoordinates.longitude, myCoordinates.latitude + curr_latdiff]);
        let radius = screen_myLocation[1] - screen_radiusEnd[1];
        // console.log("mypt:", screen_myLocation)
        // console.log("1mile pt:", screen_radiusEnd)
        // console.log("dist radius", radius)

        myLocation.attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`);
        radiusBuffer
          .attr("r", radius)
          .attr("transform", (d) => `translate(${projection([myCoordinates.longitude, myCoordinates.latitude])})`);



        //TODO: this needs new data, not just a color update
        circles.attr("fill", (d) => {
          d.dist = getDistanceFromLatLonInMiles(myCoordinates.latitude, myCoordinates.longitude, d.latitude, d.longitude);
          if (d.dist < filter_dist) {
            return selectedColor
          }
          else { return greyedoutColor }
        })

        eateriesInRadius = eateries.filter(d => d.dist < filter_dist);
        updateRestaurantInfoBox(eateriesInRadius);

      }
      var zoom = d3.zoom()
        .scaleExtent([1 << 18.5, 1 << 25])
        .on("zoom", ({ transform }) => zoomed(transform));

      svgMap
        .call(zoom)
        .call(zoom.transform, d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(- 1 << 19)
          .translate(...projection([-71.073, 42.348]))
          .scale(-1)
        )
        .on("mousewheel.zoom", null)
        .on("DOMMouseScroll.zoom", null); //disable scrolling while zooming


      function zoomed(transform) {
        // console.log("regular projection", projection([42.36541856, -71.05688332]))

        levels.each(function (delta) {
          const tiles = tile.zoomDelta(delta)(transform);

          d3.select(this)
            .selectAll("image")
            .data(tiles, d => d)
            .join("image")
            .attr("xlink:href", d => url(...d3.tileWrap(d)))
            .attr("x", ([x]) => (x + tiles.translate[0]) * tiles.scale)
            .attr("y", ([, y]) => (y + tiles.translate[1]) * tiles.scale)
            .attr("width", tiles.scale)
            .attr("height", tiles.scale);
        });


        projection
          .scale(transform.k / (2 * Math.PI))
          .translate([transform.x, transform.y]);

        circles
          .attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`);

        updateMyLocation();
      };

      //from INFO3300 notes, makes brush histogram filter

      var filters = {};

      function pointPassesFilters(point) {

        let stillPassed = true;

        Object.values(filters).forEach(filterFunc => {

          stillPassed = filterFunc(point) && stillPassed;

        });

        return stillPassed;

      }

      //calls update on filters
      function updateData() {

        // Filter the points using the filter dictionary first
        eateries = eateriesAll.filter(d => pointPassesFilters(d));

        console.log('filtered eateries', eateries);
        // console.log(eateries[0]["longitude"], eateries[0]["latitude"]);
        // console.log(projection([eateries[0]["longitude"], eateries[0]["latitude"]]));
        // console.log(projection([-71.05686665, 42.35140831]));

        // Draw the circles
        circles = svgEateries.selectAll("circle.eateries").data(eateries)
          .join("circle")
          .attr("class", "eateries")
          .attr("r", 3)
          .attr("fill", selectedColor)
          .attr("opacity", 0.9)
          .attr("transform", (d) => `translate(${projection([d.longitude, d.latitude])})`)
          .on("mouseover", (event) => {
            tooltip.style("visibility", "visible");


            let eatery = event.target.__data__

            //dynamically adjusts width, delete later
            tooltipWidth = eatery['name'].length * 10
            if (tooltipWidth < 100) { tooltipWidth = 120; }


            box.attr("width", tooltipWidth)

            txt.text(eatery['name']);
            txt2.text(`Rating: ${eatery['rating']}, ${eatery['review_count']}`)

            tooltip
              .raise();

          })
          .on("mouseout", (event) => {
            tooltip.style("visibility", "hidden");
          });


      }

    }

    requestMapData();





    function getDistanceFromLatLonInMiles(lat1, lon1, lat2, lon2) {
      var R = 3963; // Radius of the earth in miles
      var dLat = deg2rad(lat2 - lat1);
      var dLon = deg2rad(lon2 - lon1);
      var a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2)
        ;
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      var d = R * c;
      return d;
    }

    function deg2rad(deg) {
      return deg * (Math.PI / 180)
    }


    // Number of stars to create
    const numStars = 5;

    // Function to create a star element
    /* testing star generation */
    /* adapted from: https://jsfiddle.net/Auqj8/1/ */

    function createStar(isFilled, isHalf) {
      const star = document.createElement('span');
      star.classList.add('star');
      if (isFilled) {
        star.classList.add('on');
      }
      if (isHalf) {
        star.classList.add('half');
      }
      return star;
    }

    // Function to generate stars
    function generateStars(data) {

      let rating = data.rating;

      let div = document.createElement("div");

      // Clear previous stars
      div.innerHTML = '';

      // let p = document.createElement("p");
      // p.textContent = "Rating: ";
      // p.style.display = "inline"; // Set display to inline
      // div.appendChild(p);

      // Calculate full stars
      const fullStars = Math.floor(rating);

      // Calculate half star
      const hasHalfStar = rating % 1 !== 0;

      // Generate full stars
      for (let i = 0; i < fullStars; i++) {
        // const star = createStar(true, false);
        // div.appendChild(star);

        const star = document.createElement('span')
        star.className = ("fa fa-star checked");
        div.appendChild(star);

      }

      //       <span class="fa fa-star checked"></span>
      // <span class="fa fa-star checked"></span>
      // <span class="fa fa-star checked"></span>
      // <span class="fa fa-star-half-full"></span>
      // <span class="fa fa-star"></span>

      // Generate half star
      if (hasHalfStar) {
        // const halfStar = createStar(false, true);
        // div.appendChild(halfStar);

        const star = document.createElement('span')
        star.className = ("fa fa-star-half-full");
        div.appendChild(star);
      }

      // Generate empty stars
      const emptyStars = numStars - fullStars - (hasHalfStar ? 1 : 0);
      for (let i = 0; i < emptyStars; i++) {
        // const star = createStar(false, false);
        // div.appendChild(star);

        const star = document.createElement('span')
        star.className = ("fa fa-star-o");
        div.appendChild(star);
      }

      let p = document.createElement("p");
      p.textContent = ` (${data.review_count} reviews)`;
      p.style.display = "inline"; // Set display to inline
      div.appendChild(p);

      return div;
    }

    function updateRestaurantInfoBox(eateries) {
      // const STAR_RATING = {
      //   1: '★☆☆☆☆',
      //   2: '★★☆☆☆',
      //   3: '★★★☆☆',
      //   3.5: '★★★½☆',
      //   4: '★★★★☆',
      //   4.5: '★★★★½',
      //   5: '★★★★★'
      // };

      const restaurantListDiv = d3.select('#restaurantList');
      restaurantListDiv.selectAll("*").remove();

      if (eateries.length == 0) {
        restaurantListDiv
          .append('div')
          .attr('class', 'restaurant-card')
          .append('p')
          .text("Nothing meets your criteria. Try increasing distance.")
      } else {
        // Bind data to restaurant cards
        const restaurantCards = restaurantListDiv.selectAll('.restaurant-card')
          .data(eateries.slice(0, 5)); // Limit to first 5 restaurants

        // Enter selection - create new elements for restaurants
        const newRestaurantCards = restaurantCards.enter()
          .append('div')
          .attr('class', 'restaurant-card');

        const anchorTags = newRestaurantCards
          .style('color', 'inherit')
          .style('text-decoration', 'none');

        // Append anchor tags to new restaurant cards
        anchorTags.each(function (d) {
          // For each anchor tag, append details of the restaurant

          d3.select(this)
            .append('a')
            .attr('href', d => d.url) // Set href attribute to the restaurant's URL
            .attr('target', '_blank') // Open link in a new tab
            .append('p')
            .attr('class', 'restaurant-name')
            .text(d => d.name);

          d3.select(this)
            .append('div')
            .node()
            .appendChild(generateStars(d));
          // .append('p')
          // .text(d => `Rating: ${STAR_RATING[d.rating]}`);

          // d3.select(this)
          //   .append('p')
          //   .text(d => `Review Count: ${d.review_count}`);

          const categories = JSON.parse(d.categories_json).map(category => category[0]).join(', ');
          d3.select(this)
            .append('p')
            .text(`Categories: ${categories}`);

          const locationInfo = JSON.parse(d.location_json);
          d3.select(this)
            .append('p')
            .text(`Address: ${locationInfo.display_address.join(', ')}`);

          d3.select(this)
            .append('p')
            .text(d => `Snippet: ${d.snippet_text}`);
        });

        // Update existing restaurant cards
        restaurantCards.select('a')
          .attr('href', d => d.url);

        // Remove excess restaurant cards
        restaurantCards.exit().remove();
      }




      /** TODO: TO THINK ABOUT WHEN NEXT PICKUP
       *  a scroll bar to contain the resturants
       * the category icons buttons!
       * distance filter? 
       * animation to smoothen transitions
       * maybe switch the two buttons to a single toggle
       * add the rating number next to the stars and the number of reviews in '()' next to the review number
       *  create an distinction between "best of best" and "all results"
       * add comment icon for the speech
       * */
    }

  </script>

</body>